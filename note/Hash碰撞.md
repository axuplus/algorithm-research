##### 关于负载因子引出的Hash碰撞，那么如何解决Hash碰撞？

1：开放散列（open hashing）/ 拉链法（针对桶链结构，JDK1.8）：

​	其实就是将所有哈希地址为*i*的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第*i*个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。HashMap使用链表来解决碰撞问题，当碰撞发生了，对象将会存储在链表的下一个节点中。HashMap在每个链表节点存储键值对对象。当两个不同的键却有相同的HashCode时，他们会存储在同一个bucket位置的链表中。键对象的equals()来找到键值对。



2：封闭散列（closed hashing）/ 开放定址法：

​		开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。其实就是在数组的基础上，根据key进行哈希进行定位，如果发生碰撞（碰撞指计算得到的hash地址有值），会使用相关算法解决碰撞问题。解决碰撞的算法包括：线性探查，二次探查，以及伪随机序列算法。

​	【线性探测再散列】：特点是冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

​										（使用例子：ThreadLocal里面的ThreadLocalMap）

​	【二次探测再散列】：特点是冲突发生时，在表的左右进行跳跃式探测，比较灵活。说白了就是把条件先加后										减来探测，如果先加是冲突的，再去做加减运算来探测尝试

​										*H1 =*（*3 + 12*）*% 11 = 4*			*H2 =*（*3 - 12*）*% 11 = 2*

​	【伪随机序列探测再散列】：跟上面的二次探测再散列做法一样，只不过条件变成了随机数 直到不冲突为止

3：再哈希法/再散列法：

​		当哈希地址*Hi=RH1*（*key*）发生冲突时，再计算*Hi=RH2*（*key*）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。也就是说使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置，缺点就是每次冲突都要重新散列，时间复杂度（asymptotic time complexity）严重上升。
